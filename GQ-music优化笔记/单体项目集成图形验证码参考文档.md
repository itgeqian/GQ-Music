Ran tool
Ran tool
Ran tool
### 目标
基于当前项目的实现，指导你在另一个单体 Spring Boot 项目中，从 0 到 1 接入“同款图形验证码”（算术验证码），包括：生成图、回传校验 key、Redis 存取、接口校验与前端使用方式。

### 技术选型
- 验证码库：`com.github.whvcse:easy-captcha`（项目中通过 `com.wf.captcha.ArithmeticCaptcha` 使用）
- 缓存：Redis（保存验证码值，设置有效期）
- 前后端交互：后端返回 Base64 图片与验证码 key；前端携带 `checkCodeKey` 和用户输入 `checkCode` 提交

---

### 一、后端接入

#### 1) 依赖
Maven 加入（仅示例，按你现有版本管理为准）：
```xml
<dependency>
  <groupId>com.github.whvcse</groupId>
  <artifactId>easy-captcha</artifactId>
  <version>1.6.2</version>
</dependency>
<!-- Redis 客户端与工具，按你的项目已有为准 -->
```

#### 2) Redis 键与有效期
参考本项目常量定义（有效期 10 分钟）：
```java
// 以你项目的常量类为准
public static final String REDIS_KEY_PREFIX = "easylive:";
public static final String REDIS_KEY_CHECK_CODE = REDIS_KEY_PREFIX + "checkcode:";
public static final Integer REDIS_KEY_EXPIRES_ONE_MIN = 60000; // 1分钟（毫秒）
```
保存/获取/清理（参考本项目 `RedisComponent`）：
```java
public String saveCheckCode(String code) {
    String checkCodeKey = UUID.randomUUID().toString();
    redisUtils.setex(REDIS_KEY_CHECK_CODE + checkCodeKey, code, REDIS_KEY_EXPIRES_ONE_MIN * 10);
    return checkCodeKey;
}
public String getCheckCode(String checkCodeKey) {
    return (String) redisUtils.get(REDIS_KEY_CHECK_CODE + checkCodeKey);
}
public void cleanCheckCode(String checkCodeKey) {
    redisUtils.delete(REDIS_KEY_CHECK_CODE + checkCodeKey);
}
```

关键实现参考：
```34:49:easylive-server/easylive-cloud/easylive-cloud-common/src/main/java/com/easylive/component/RedisComponent.java
```

#### 3) 后端验证码接口
按本项目的 `AccountController#checkCode` 返回 Base64 图和 key：
```java
@RequestMapping("/checkCode")
public ResponseVO<?> checkCode() {
    ArithmeticCaptcha captcha = new ArithmeticCaptcha(100, 42); // 宽/高
    String code = captcha.text();                                // 算术表达式结果，如 "7"
    String checkCodeKey = redisComponent.saveCheckCode(code);    // 保存 Redis，10 分钟
    String checkCodeBase64 = captcha.toBase64();                  // data:image/png;base64,xxxx

    Map<String, String> result = new HashMap<>();
    result.put("checkCode", checkCodeBase64);
    result.put("checkCodeKey", checkCodeKey);
    return getSuccessResponseVO(result);
}
```
参考代码位置：
```62:73:easylive-server/easylive-cloud/easylive-cloud-web/src/main/java/com/easylive/controller/AccountController.java
```

#### 4) 后端业务接口校验
以“登录”为例（注册、重置密码同理）：
```java
public ResponseVO<?> login(..., @NotEmpty String checkCodeKey, @NotEmpty String checkCode) {
  try {
    if (!checkCode.equalsIgnoreCase(redisComponent.getCheckCode(checkCodeKey))) {
      throw new BusinessException("图片验证码不正确");
    }
    // 你的业务逻辑：认证、签发 token 等
    return getSuccessResponseVO(tokenUserInfoDto);
  } finally {
    redisComponent.cleanCheckCode(checkCodeKey); // 用后即删，防重放
  }
}
```
参考代码位置：
```170:201:easylive-server/easylive-cloud/easylive-cloud-web/src/main/java/com/easylive/controller/AccountController.java
```

实践建议：
- 验证通过后建议清理 Redis（本项目是 finally 中删除）。
- 参数命名统一：`checkCodeKey` + `checkCode`。

---

### 二、前端接入

#### 1) 拉取验证码图与 key
- 页面加载/刷新验证码时调用 `/account/checkCode`，拿到：
  - `checkCode`: Base64（可以直接绑定到 `<img :src="checkCode">`）
  - `checkCodeKey`: 需要一并提交给后端进行校验

参考现有前端实现（`Account.vue`）：
```javascript
const checkCodeInfo = ref({});
const captchaSpin = ref(false);

const changeCheckCode = async () => {
  if (captchaSpin.value) return;
  captchaSpin.value = true;
  let result = await proxy.Request({ url: proxy.Api.checkCode });
  if (!result) { captchaSpin.value = false; return; }
  checkCodeInfo.value = result.data; // 包含 checkCode, checkCodeKey
  setTimeout(() => (captchaSpin.value = false), 250);
};
```
引用位置：
```237:253:easylive-front/easylive-front-web/src/views/account/Account.vue
```

模板片段（展示和刷新）：
```html
<div class="check-code-panel">
  <el-input v-model="formData.checkCode" placeholder="请输入验证码" @keyup.enter="doSubmit">
    <template #prefix><span class="iconfont icon-checkcode"></span></template>
  </el-input>
  <img :src="checkCodeInfo.checkCode" :key="checkCodeInfo.checkCode" class="check-code" @click="changeCheckCode()" />
</div>
```
引用位置：
```166:185:easylive-front/easylive-front-web/src/views/account/Account.vue
```

#### 2) 提交时携带 key 与用户输入值
```javascript
let params = { ...formData.value };
params.checkCodeKey = checkCodeInfo.value.checkCodeKey;

let result = await proxy.Request({
  url: proxy.Api.login, // 或 register/reset
  params,
  errorCallback: () => { changeCheckCode(); } // 校验失败时刷新图
});
```
引用位置：
```333:349:easylive-front/easylive-front-web/src/views/account/Account.vue
```

---

### 三、常见问题与最佳实践

- 验证码刷新时机
  - 初始加载
  - 用户点击图片手动刷新
  - 后端判定验证码错误时，前端应主动 `changeCheckCode()` 刷新
- 安全建议
  - 验证码 key 设置短期有效（本项目 10 分钟）
  - 校验后立即删除 Redis 记录，避免重放
  - 对连续错误可做频控（可选）
- UI/UX
  - 输入框与图片并排显示，图片可点击更换
  - 验证码字段的校验信息与其他表单项一致

---

### 四、你在单体项目中的落地清单

1) 加 `easy-captcha` 依赖；确保 Redis 可用（封装 setex/get/delete）。
2) 新建验证码接口：
   - 生成 `ArithmeticCaptcha(width,height)` → `text()` → 存 Redis → `toBase64()` 返回 `checkCode` 与 `checkCodeKey`。
3) 在登录/注册/重置密码等接口中：
   - 接收 `checkCodeKey` 与 `checkCode`
   - 从 Redis 取真实 code 对比
   - finally 中 `cleanCheckCode(checkCodeKey)`
4) 前端：
   - 页面加载或点击刷新时调用验证码接口并展示图片
   - 表单提交时携带 `checkCodeKey` 与 `checkCode`
   - 后端判错时刷新验证码

按以上步骤，你能在新项目中快速复用“同款图形验证码”。需要我为你的单体项目直接生成 Controller + Redis 工具类样例代码，也可以继续发我项目结构，我帮你落地。